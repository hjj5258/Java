### 操作系统导论week1总结

- 为什么有操作系统？

  - 我们来看看在没有操作系统的时候，冯·诺依曼（Von Neumann）体系，这里举一个程序运行的例子：处理器从内存中获取指令，然后进行解码（弄清楚是哪条指令），然后执行它，如两个数进行相加、访问内存、检查条件、跳转函数等，为了简化，人们在上层添加了操作系统层，使得程序与设备或者资源交互更加容易，让编写程序的人不在担心如何与设备进行交互，更加的关心程序想要达到什么目的，操作系统对外暴露了很多接口，我们只需要关心接口如何使用，而不在担心如何接口如何实现。

  - 它取得CPU、内存或磁盘等物理资源（resources），并对它们进行虚拟化（virtualize）。它处理与并发（concurrency）有关的麻烦且棘手的问题。它持久地（persistently）存储文件，从而使它们长期安全。鉴于我们希望建立这样一个系统，所以要有一些目标，以帮助我们集中设计和实现，并在必要时进行折中。找到合适的折中是建立系统的关键。

- 什么是操作系统？

  - 可以容易的让程序运行变得容易，允许程序共享内存，能够让设备与程序进行交互。

- 虚拟化

  - 虚拟化CPU

    - 操作系统负责提供这种假象（illusion），即系统拥有非常多的虚拟CPU的假象。将单个CPU（或其中一小部分）转换为看似无限数量的CPU，从而让许多程序看似同时运行，这就是所谓的虚拟化CPU（virtualizingthe CPU）。

    - 它是如何制造虚拟化CPU？
      - 我们知道在还没有操作系统的时候（条件为单核CPU），如果运行一个程序那么只能等这个程序执行完毕之后才能执行下一个程序，为了可以执行多个程序，操作系统将CPU的资源分割成时间片，让执行变成以时间片为单位，例如我运行多个程序，程序1获得了时间片那么程序1就得以执行，程序2此时获得了时间片程序2得以执行，然后进行来回的切换，在多个程序之间切换我们称为，上下文切换，只是切换的速度很快，对于用户来说感知不到，这就是时分共享（time sharing），是操作系统共享资源所使用的最基本的技术之一。通过允许资源由一个实体使用一小段时间，然后由另一个实体使用一小段时间，如此下去，所谓的资源（例如，CPU或网络链接）可以被许多人共享。

  - 虚拟化内存

    - 我们做到访问内存必须知道地址，知道地址才能读入，更新内存。

    - 每个进程都有自己的私有虚拟地址空间，操作系统以某种方式映射到机器的物理内存上。

- 并发

  - 例如运行一个不断的累加的程序，有很多并发执行的线程，在操作同一个内存空间，如果代码不谨慎，此时有可能存在不正确的结果，程序将计数器的值从内存加载到寄存器，然后递增，再然后保存回内存。但指令并不是以原子方式（atomically）执行（所有的指令一次性执行）的，所以奇怪的事情可能会发生

- 持久性

  - 在操作系统中存储数据，而管理这些数据通常被称为文件系统（file system），因此它负责以可靠和高效的方式，将用户创建的任何文件（file）存储在系统的磁盘上。

  - 在操作系统上操作文件，分为三步：

    - 第一步open()打开文件。

    - 第二步是write()，将一些数据写入文件。

    - 第三步是close()，只是简单地关闭文件，从而表明程序不会再向它写入更多的数据

- 进程

  - 进程就是运行中的程序，一个进程只是一个正在运行的程序

  - 机器状态（machine state）：程序在运行时可以读取或更新的内容

    - 内存：正在运行的程序读取和写入的数据也在内存中。因此进程可以访问的内存（称为地址空间，address space）

    - 寄存器：许多指令明确地读取或更新寄存器，因此显然，它们对于执行该进程很重要

    - 程序计数器（ProgramCounter，PC）：告诉我们程序当前正在执行哪个指令

    - 栈指针（stackpointer）：管理函数参数栈、局部变量

    - 帧指针（frame pointer）：返回地址

  - API

    - 创建（create）：操作系统必须包含一些创建新进程的方法。

    - 销毁（destroy）：由于存在创建进程的接口，因此系统还提供了一个强制销毁进程的接口。

    - 等待（wait）：有时等待进程停止运行是有用的，因此经常提供某种等待接口。

    - 其他控制（miscellaneous control）：除了杀死或等待进程外，有时还可能有其他控制。

    - 状态（statu）：通常也有一些接口可以获得有关进程的状态信息，例如运行了多长时间，或者处于什么状态。![img](0ae41fae-bef9-4a62-bb47-aa043d1ed60a-6876160.jpg)

  - 数据结构
    - 操作系统追踪进程的一些重要信息。对于停止的进程，寄存器上下文将保存其寄存器的内容。当一个进程停止时，它的寄存器将被保存到这个内存位置。通过恢复这些寄存器（将它们的值放回实际的物理寄存器中），操作系统可以恢复运行该进程。![img](c0baa8a8-4e42-4fb1-a8d6-a5be09bbd2ee-6876160.jpg)

  - 进程API的使用

    - fork()系统调用
      - 会从本进程copy一个进程，此时子进程会进行初始化，它拥有自己的地址空间（即拥有自己的私有内存）、寄存器、程序计数器，通过返回值可以判断父子进程，返回值等于0则是子进程，至于什么时候子进程执行，我们不能掌控，有可能在父进程调用的fork()之后或者之前，CPU调度程序（scheduler）决定了某个时刻哪个进程被执行。

    - wait()系统调用
      - 父进程需要等待子进程执行完毕，可以用wait()来控制进程执行顺序

    - exec()系统调用
      - 可以创建一个进程运行其他程序，fork()是copy，exec()则是让你自由选择。